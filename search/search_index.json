{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tutorial","text":""},{"location":"#summary","title":"Summary","text":"<p>The goal of this tutorial is for you to have Music API ready to receive songs, albums, and artists. While you learn Django and Django Rest Framework a.k.a DRF to build you first API</p> <p>Requirements list:</p> <ol> <li>Python 3.12</li> <li>Git</li> <li>uv</li> </ol> <ul> <li>Total Duration: 3 hours 30 minutes</li> <li>Lecture: 1 hour (approximately 30%)</li> <li>Exercises: 2 hours 30 minutes (approximately 70%)</li> </ul>"},{"location":"#who-am-i","title":"Who am I?","text":"<p> Hey! I'm FeliPython a.k.a. Felipe de Morais. \ud83d\udc4b\ud83c\udffe I'm a seasoned software engineer with extensive experience in Python, Django development, and now FastAPI. \ud83d\udc0d</p> <p>When I'm not coding, you'll find me rolling on the mats as a [Brazilian] Jiu Jitsu Blue Belt, embracing the discipline and challenges of the sport. Because life needs a furry friend, I train my dog solo, which has been an incredibly rewarding experience. \ud83d\udc15</p> <p>Presentation slides \ud83d\udcca</p>"},{"location":"#introduction-and-overview","title":"Introduction and Overview","text":""},{"location":"#django","title":"Django","text":"<p>To start, we first need to understand what Django is. Django is the most popular web framework in the Python ecosystem, characterized by its high-level structure that encourages rapid development and clean, pragmatic design. It has been constructed by experienced developers and aims to mitigate the hassles of web development; this allows developers to focus their attention on writing their app without feeling the need to reinvent the wheel. Django is a free and open-source framework that is ingrained in the model-template-views architectural pattern. Its maintenance is overseen by the Django Software Foundation, an independent, non-profit organization based in the United States.</p>"},{"location":"#django-rest-framework","title":"Django Rest Framework","text":"<p>The Django Rest Framework is a powerful library constructed on top of Django, with a unique interlinking to the Django Model. This relationship endows Django with the enhanced ability to create APIs(application programming interfaces).</p> <p>An important thing to know about Django is how the information usually flows</p> <pre><code>sequenceDiagram \n    participant B as Browser\n    participant DS as Django Server\n    participant UP as URL Patterns \n    participant V as View\n\n    B-&gt;&gt;DS: Sends HTTP request \n    DS-&gt;&gt;UP: Matches HTTP request to URL patterns\n    UP-&gt;&gt;V: Calls appropriate View with request object \n    V--&gt;&gt;UP: Response object\n    UP--&gt;&gt;DS: Returns HTTP response\n    DS--&gt;&gt;B: JSON response(in our case)</code></pre> <p>The sequence diagram illustrates the flow of an HTTP request through the Django web framework. Let's break it down step by step:</p> <ol> <li> <p>Browser Sends HTTP Request: The process begins when the user interacts with the browser, triggering an HTTP request. This request is sent to the Django server.</p> </li> <li> <p>Django Server Receives Request: Upon receiving the request, the Django server forwards it to the URL dispatcher (URL Patterns) to determine which view function should handle it.</p> </li> <li> <p>URL Patterns Match Request to View: The URL dispatcher matches the incoming HTTP request to the appropriate view function based on the URL patterns defined in the Django project. It then calls the corresponding view function, passing along the request object.</p> </li> <li> <p>View Processes Request: The view function performs the necessary processing based on the request received. This could involve querying the database, performing business logic, or any other required tasks. Once the processing is complete, the view returns a response object.</p> </li> <li> <p>Response Travels Back: The response object generated by the view function travels back through the same path it came from, starting with the URL dispatcher. The response is passed back to the Django server.</p> </li> <li> <p>HTTP Response Returned: The Django server sends the HTTP response, typically in the form of JSON data in your case, back to the browser, fulfilling the original request.</p> </li> </ol> <p>This sequence outlines the typical flow of a request-response cycle in Django, demonstrating how requests are handled and responses are generated within the framework.</p>"},{"location":"#set-up-the-project","title":"Set up the project","text":"<p>Now we have a basic understanding of Django and DRF. We are going to set up the project.</p> <p>Clone the repository:</p> <pre><code>git clone git@github.com:lipemorais/building-your-first-api-with-django-and-django-rest-framework.git\n</code></pre> <p>With the repository cloned, you need to install uv on your machine to manage the project and dependencies here: uv instalation instruction</p> <p>Now you have the project cloned and uv installed, you need to follow these steps on create your virtualenv and install the dependencies.</p> <pre><code>cd building-your-first-api-with-django-and-django-rest-framework\nuv venv\nsource .venv/bin/activate # if you are on Windows use: .venv\\Scripts\\activate\nuv sync\ntask r # to see the application running\n</code></pre> <p>You might be able to see the application running o 127.0.0.1:8000.</p> <p></p> <p>Well done! Now you are all set!</p>"},{"location":"#creating-the-music-django-app","title":"Creating the music Django App","text":"<p>Now we are going to dive into the Django world, creating the Music app we are going to use in this tutorial.</p> <pre><code>cd first_api\n./manage.py startapp music\n</code></pre> <p>This will create the app structure for us. Something similar to this below: <pre><code>\u276f tree .\n.\n\u251c\u2500\u2500 db.sqlite3\n\u251c\u2500\u2500 first_api\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 asgi.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 settings.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 urls.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 wsgi.py\n\u251c\u2500\u2500 manage.py\n\u2514\u2500\u2500 music\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 admin.py\n    \u251c\u2500\u2500 apps.py\n    \u251c\u2500\u2500 migrations\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 models.py\n    \u251c\u2500\u2500 tests.py\n    \u2514\u2500\u2500 views.py\n</code></pre></p> <p>Don't forget to add the app music to your INSTALLED_APPS in your <code>settings.py</code> <pre><code># first_api/settings.py\n...\nINSTALLED_APPS = [\n    \"django.contrib.admin\",\n    \"django.contrib.auth\",\n    \"django.contrib.contenttypes\",\n    \"django.contrib.sessions\",\n    \"django.contrib.messages\",\n    \"django.contrib.staticfiles\",\n    \"rest_framework\",\n    \"music\",\n]\n...\n</code></pre></p>"},{"location":"#django-models","title":"Django Models","text":"<p>Now the next step is create the models we are going to use in our API to represent the domain models.</p> <p>We are going to create 3 models in the file models.py</p> <ol> <li>Artist</li> <li>Album</li> <li>Song</li> </ol> <p>Let's start with the artist model.</p> <pre><code># music/models.py\nclass Artist(models.Model):\n    name = models.CharField(max_length=100)\n\n    def __str__(self):\n        return self.name\n</code></pre> <p>Don't forget to import the models</p> <pre><code>from django.db import models\n</code></pre> <p>Now the album model</p> <pre><code># music/models.py\nclass Album(models.Model):\n    title = models.CharField(max_length=100)\n    artist = models.ForeignKey(Artist, on_delete=models.CASCADE)\n    release_year = models.IntegerField()\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>The last model will be the song model that will have relationship with artist and album.</p> <pre><code># music/models.py\nclass Song(models.Model):\n    author = models.CharField(max_length=100)\n    title = models.CharField(max_length=100)\n    artist = models.ForeignKey(Artist, on_delete=models.CASCADE)  # Artist or band name\n    album = models.ForeignKey(Album, on_delete=models.CASCADE)  # Album the song belongs to\n    duration = models.IntegerField()  # Duration of the song in seconds\n</code></pre>"},{"location":"#url-mapping-and-views","title":"URL Mapping and Views","text":"<p>Now let's go to the URL Mapping, we need to associate the url with the handler functions that are called as view in Django. To create a simple endpoint that works.</p> <pre><code># first_api/urls.py\nfrom django.contrib import admin\nfrom django.urls import path, include\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"\", include('music.urls')),\n]\n</code></pre> <p>You need to create a file <code>urls.py</code> inside music folder and make it look like the example below.</p> <pre><code># music/urls.py\nfrom django.urls import path\n\nfrom . import views\n\nurlpatterns = [\n    path('', views.index, name='index')\n]\n</code></pre> <p>And last but not least you need to create this you need to create the view. A function view in this case.</p> <pre><code># music/views.py\nfrom django.http import HttpResponse\n\n\ndef index(_request):\n    return HttpResponse(\"My first API!\")\n</code></pre> <p>So now you can use the command <code>task r</code> to start our django server, so you can access http://127.0.0.1:8000/ to see it. </p> <p>Until here we just looked at Django concepts. Now we will dive into Django Rest Framework(DRF) concepts.</p>"},{"location":"#serializers","title":"Serializers","text":"<p>From now on we will dive into DRF specific work. The concept I want to present you is the Serializer. That is responsible for parse the data received(usually through a HTTP request, since we are creating an API) into python native types, and sometime into our Django models.</p> <p>Serializers are deeply inspired into Django Forms and Django Model Forms</p> <p>So now we will use our Artist model to create our first endpoint.</p> <p>You need to create a file called <code>serializers.py</code> with creating the serializer for the Artist Model.</p> <pre><code>from rest_framework import serializers\n\nfrom music.models import Artist\n\n\nclass ArtistSerializer(serializers.HyperlinkedModelSerializer):\n    class Meta:\n        model = Artist\n        fields = ['name']\n</code></pre> <ol> <li>Here we import the serializers module from rest_framework</li> <li>We also import the model Artist</li> <li>Create a <code>ArtistSerializer</code> inheriting from <code>serializers.HyperlinkedModelSerializers</code>. It will do a few things.</li> <li>Create a Serializer based on the Artist Model based on the model field in the Meta class.</li> <li>Create hyperlinks for the relationships</li> <li>We need to pass explicitly the fields from the Artist model that will be in the serializer at the <code>fields</code> in the Meta class.</li> </ol> <p>With the serializer in place we need more 2 steps, the view and the url mapping.</p> <p>Let's do both in sequence, first the view. For the view we are going to use a ModelViewSet. Inside our file <code>music.views.py</code> we need to add this snippet.</p> <pre><code># music/views.py\n...\nclass ArtistViewSet(viewsets.ModelViewSet):\n    queryset = Artist.objects.all()\n    serializer_class = ArtistSerializer\n</code></pre> <ol> <li>Here we create a ViewSet class that will be responsible for creating our CRUD(+ list) views. It inherits from <code>ModelViewSet</code>.</li> <li><code>queryset</code> parameter tells DRF what do list, this will be shared across all the views</li> <li><code>serializer_class</code> is self-explanatory</li> </ol> <p>Don't forget to add the imports at the beggining of the file.</p> <pre><code>from rest_framework import viewsets\n\nfrom music.models import Artist\nfrom music.serializers import ArtistSerializer\n</code></pre>"},{"location":"#building-an-api-part-i","title":"Building an API - Part I","text":"<p>Ok, now we just need to map our ArtistViewSet to a URL. In our <code>music.urls.py</code> we are going to use one more resource that DRF provides us, the Default Router. It will create a set of common routes for our ViewSet. This will be the code:</p> <pre><code># music/urls.py\nfrom django.urls import path, include\nfrom rest_framework import routers\n\nfrom . import views\nfrom .views import ArtistViewSet\n\nrouter = routers.DefaultRouter()\nrouter.register(r'artists', ArtistViewSet)\n\nurlpatterns = [\n    path('', include(router.urls)),\n    # path('', views.index, name='index'),\n]\n</code></pre> <ol> <li>Import the routers from DRF</li> <li>Import the ArtistViewSet</li> <li>Instantiate the DefaultRouter</li> <li>Register the artists route to the ArtistViewSet</li> <li>So we include it on our urlpatterns</li> <li>And comment the previous endpoint we have, to avoid conflicts</li> </ol> <p>Now to see it all working together we need to create the migrations for our models with the following steps.</p> <pre><code>cd first_api\n./manage.py makemigrations music\n./manage.py migrate music\ncd ..\ntask r\n</code></pre> <p>Now access http://127.0.0.1:8000/ to see your API working. \ud83e\udd73</p> <p>Congratulations now you have your first api working.</p> <p></p>"},{"location":"#building-an-api-part-ii","title":"Building an API - Part II","text":"<p>Now that you've explored some of the shortcuts provided by DRF, let's delve into creating an endpoint for the album model using a plain Serializer, without relying heavily on shortcuts.</p> <p>Let's start by the urls part. We're going to need to add the new route to our <code>music.urls.py</code>. Now it should look like this.</p> <pre><code>from django.urls import path, include\nfrom rest_framework import routers\n\nfrom . import views\nfrom .views import ArtistViewSet, AlbumViewSet\n\nrouter = routers.DefaultRouter()\nrouter.register(r'artists', ArtistViewSet)\nrouter.register(r'albums', AlbumViewSet)\n\nurlpatterns = [\n    path('', include(router.urls)),\n    # path('', views.index, name='index'),\n]\n</code></pre> <ol> <li>We added a new import for the AlbumViewSet</li> <li>We added the routes for albums</li> </ol> <p>Next is the <code>AlbumViewSet</code> in the <code>music.views.py</code>. I will break it down in some steps.</p> <pre><code>class AlbumViewSet(viewsets.ViewSet):\n    queryset = Album.objects.all()\n    serializer_class = AlbumSerializer\n</code></pre> <ol> <li>Here we create a class <code>AlbumViewSet</code> inheriting from <code>views.ViewSet</code>, pay attention, this is not a model view set.</li> <li>Set the <code>queryset</code></li> <li>Set <code>serializer_class</code>, we are going to talk about this <code>AlbumSerializer</code> later</li> <li>For now, just import the <code>AlbumSerializer</code> with <code>from music.serializers import AlbumSerializer</code></li> <li>Don't forget to import the Album model here with <code>from music.models import Album</code></li> </ol> <p>After this still in the same view we are going through what DRF call actions. Instead of have methods in the view set for get, post, delete... It has functions based on actions. The actions are the ones below:</p> <pre><code>class AlbumViewSet(viewsets.ViewSet):\n    queryset = Album.objects.all()\n    serializer_class = AlbumSerializer\n\n    def list(self, request):\n        \"\"\"\n        List the resources, albums in this case\n        \"\"\"\n        pass\n\n    def create(self, request):\n        \"\"\"\n        Create a new resource, albums in this case\n        \"\"\"\n        pass\n\n    def retrieve(self, request, pk=None):\n        \"\"\"\n        Retrieve a single resource, album in this case\n        \"\"\"\n        pass\n\n    def update(self, request, pk=None):\n        \"\"\"\n        Update the resource, album in this case\n        \"\"\"\n        pass\n\n    def partial_update(self, request, pk=None):\n        \"\"\"\n        Partially update the resource, album in this case\n        \"\"\"\n        pass\n\n    def destroy(self, request, pk=None):\n        \"\"\"\n        Delete the resource, album in this case\n        \"\"\"\n        pass\n</code></pre> <p>With the actions in place we will fill each of these methods. First the <code>list</code> method.</p> <pre><code>    def list(self, request):\n        serializer = self.serializer_class(self.queryset, many=True)\n        return Response(serializer.data)\n</code></pre> <ol> <li>Here we just need to serialize the queryset and return it as a <code>Response</code></li> <li>Don't forget to import the <code>from rest_framework.response import Response</code></li> </ol> <p>The following action will be <code>create</code></p> <pre><code>    def create(self, request):\n        serializer = self.serializer_class(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data, status=status.HTTP_201_CREATED)\n</code></pre> <ol> <li>Here we need to serialize the <code>request.data</code></li> <li>Check if it <code>is_valid</code></li> <li>Save our Album(There is caveat here I will show later how to fix)</li> <li>And return a response with the <code>serializer.data</code>a and a https status</li> <li>Don't forget to import <code>from rest_framework import status</code></li> </ol> <p>Next is <code>retrieve</code></p> <pre><code>    def retrieve(self, request, pk=None):\n        album = get_object_or_404(Album, pk=pk)\n        serializer = self.serializer_class(album)\n        return Response(serializer.data)\n</code></pre> <ol> <li>We try to get the album using the <code>get_object_or_404</code> from <code>from rest_framework.generics import get_object_or_404</code></li> <li>serialize it and send it back as a response</li> </ol> <p>So we have the <code>update</code></p> <pre><code>    def update(self, request, pk=None):\n        album = get_object_or_404(Album, pk=pk)\n        serializer = self.serializer_class(album, data=request.data)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n</code></pre> <ol> <li>Similarly to the previous one but this time we update just the needed fields</li> </ol> <p>For <code>partial_update</code> is close to the one above</p> <pre><code>    def partial_update(self, request, pk=None):\n        album = get_object_or_404(Album, pk=pk)\n        serializer = self.serializer_class(album, data=request.data, partial=True)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        return Response(serializer.data)\n</code></pre> <ol> <li>the only difference here from the <code>update</code> above is the <code>partial=True</code> so it know that it just need to update some fields not all of them.</li> </ol> <p>Last but not least <code>destroy</code> action to delete albums</p> <pre><code>    def destroy(self, request, pk=None):\n        album = get_object_or_404(Album, pk=pk)\n        album.delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre> <ol> <li>Here we need to get the album and call the <code>.delete()</code> on it</li> </ol> <p>With <code>destroy</code> set the we finish the change on <code>music.views.py</code></p> <p>Now we go for our <code>AlbumSerializer</code></p> <pre><code>class AlbumSerializer(serializers.Serializer):\n    title = serializers.CharField()\n    artist = ArtistSerializer()  # Serializers inherits from Field, so it can be used as fields too\n    release_year = serializers.IntegerField()\n\n    class Meta:\n        fields = ['title', 'artist', 'release_year']\n</code></pre> <ol> <li>First we define our <code>AlbumSerializer</code> inheriting from <code>serializers.Serializer</code></li> <li>With the fields <code>title</code>, <code>artist</code>, <code>release_year</code> with it respective fields</li> <li>We also need to list the fields inside the class Meta</li> </ol> <p>Additionally, we need to add 2 methods to let DRF know how to save and how to update the Albums.</p> <p>The first is <code>create</code></p> <pre><code>    def create(self, validated_data):\n        artist_data = validated_data.pop('artist')\n        artist, created = Artist.objects.get_or_create(name=artist_data['name'])\n        return Album.objects.create(artist=artist, **validated_data)\n</code></pre> <ol> <li>We create the album, but since the album has artist as a nested model, we need to create it here before try to save the album itself.</li> <li>Don't forget to import the <code>Album</code> model here with <code>from music.models import Album</code></li> </ol> <p>and the <code>update</code> method</p> <pre><code>    def update(self, album, validated_data):\n        artist_data = validated_data.pop('artist')\n        artist, created = Artist.objects.get_or_create(name=artist_data['name'])\n\n        album.title = validated_data.get('title', album.title)\n        album.release_year = validated_data.get('release_year', album.release_year)\n        album.artist = artist\n        album.save()\n\n        return album\n</code></pre> <ol> <li>To update we need to do the same with the <code>Artist</code> model, creating/getting it before save the Album</li> <li>So we get the new fields and save it</li> <li>Last we return the updated album</li> </ol> <p>With everything set we can see it working live.</p> <p>Now we have 2 resources here, artists and albums</p> <p></p> <p>I hope that at this time you understand the amount of shortcuts DRF gives you at the same time, if you want to customize it, it's still possible.</p>"},{"location":"#building-an-api-part-iii","title":"Building an API - Part III","text":""},{"location":"#easy-version","title":"Easy version","text":"<p>We are going to start from the urls one more time. We will add the route for the songs in our <code>music.urls</code> like in the snippet below</p> <pre><code>from django.urls import path, include\nfrom rest_framework import routers\n\nfrom .views import ArtistViewSet, AlbumViewSet, SongViewSet\n\nrouter = routers.DefaultRouter()\nrouter.register(r'artists', ArtistViewSet)\nrouter.register(r'albums', AlbumViewSet)\n# Add this new line below\nrouter.register(r'songs', SongViewSet)\n\nurlpatterns = [\n    path('', include(router.urls)),\n    # path('', views.index, name='index'),\n]\n</code></pre> <p>After this we are going to create the <code>SongViewSet</code> in our <code>music.views</code> file using a <code>ModelViewSet</code> like in the snippet below. Also update Don't forget to add the import for <code>Song</code> and <code>SongSerializer</code> in your imports</p> <pre><code>from music.models import Artist, Album, Song\nfrom music.serializers import ArtistSerializer, AlbumSerializer, SongSerializer\n\nclass SongViewSet(viewsets.ModelViewSet):\n    queryset = Song.objects.all()\n    serializer_class = SongSerializer\n</code></pre> <p>At this point the <code>SongSerializer</code> doesn't exist yet, so now we are going to create it. Here also update the imports for the models including the <code>Song</code> model. Here there is a snippet so you see the changes you have to do on you <code>music.serializers</code> file.</p> <pre><code>from music.models import Artist, Album, Song\n\nclass SongSerializer(serializers.HyperlinkedModelSerializer):\n    class Meta:\n        model = Song\n        fields = ['author', 'title', 'artist', 'album', 'duration']\n</code></pre> <p>With this part done you will be able to run you application and see something like this on you api with all 3 resource working in your API, Artist, Album and Song. \ud83e\udd73</p> <p></p> <p>Now you api is complete! Congratulations! \ud83c\udf7e\ud83c\udf89\ud83c\udf8a</p>"},{"location":"bonus/","title":"Bonus","text":""},{"location":"bonus/#bonus-content","title":"Bonus content","text":""},{"location":"bonus/#serializers-deep-dive","title":"Serializers deep dive","text":""},{"location":"bonus/#types","title":"Types","text":"<ol> <li>Serializer</li> <li>Model Serializer</li> <li>Hyperlinked Model Serializer</li> </ol>"},{"location":"bonus/#serializer-fields","title":"Serializer fields","text":"<ol> <li>Boolean</li> <li>String</li> <li>Numeric</li> <li>Date and time</li> </ol>"},{"location":"bonus/#serializer-relations","title":"Serializer relations","text":""},{"location":"bonus/#validators","title":"Validators","text":""},{"location":"bonus/#routers","title":"Routers","text":""},{"location":"bonus/#viewsets","title":"ViewSets","text":""},{"location":"bonus/#the-browsable-api","title":"The Browsable API","text":""},{"location":"sample/","title":"Sample!","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"sample/#mermaid","title":"mermaid","text":"<pre><code>sequenceDiagram\n    Alice -&gt;&gt; Bob: Hello Bob, how are you?</code></pre>"},{"location":"sample/#code-annotation-examples","title":"Code Annotation Examples","text":""},{"location":"sample/#codeblocks","title":"Codeblocks","text":"<p>Some <code>code</code> goes here.</p>"},{"location":"sample/#plain-codeblock","title":"Plain codeblock","text":"<p>A plain codeblock:</p> <pre><code>Some code here\ndef myfunction()\n// some comment\n</code></pre>"},{"location":"sample/#code-for-a-specific-language","title":"Code for a specific language","text":"<p>Some more code with the <code>py</code> at the start:</p> <pre><code>import tensorflow as tf\ndef whatever()\n</code></pre>"},{"location":"sample/#with-a-title","title":"With a title","text":"bubble_sort.py<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"sample/#with-line-numbers","title":"With line numbers","text":"<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"sample/#highlighting-lines","title":"Highlighting lines","text":"<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre>"},{"location":"sample/#icons-and-emojs","title":"Icons and Emojs","text":""}]}